"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.initBridgeService = exports.getConnectionStatus = exports.getConnectionPayload = exports.postMessage = exports.onConnectObservable = exports.bridgeServiceObservable = void 0;
var constants_1 = require("../constants");
var mock_1 = require("../request/mock");
var isDevelopment_1 = __importDefault(require("../utils/isDevelopment"));
var isLocalDev_1 = __importDefault(require("../utils/isLocalDev"));
var observable_1 = __importDefault(require("../utils/observable"));
var viewSource;
var status = 'pending';
var connectionPayload = {};
/**
 * When any message comes
 */
exports.bridgeServiceObservable = new observable_1["default"]();
/**
 * When the connection is established
 */
exports.onConnectObservable = new observable_1["default"]();
// Message concurrency controll
var lastMsgSentAt = new Date();
/**
 * Post message
 * @param message
 * @returns
 */
var postMessage = function (message) {
    if (!viewSource && !isLocalDev_1["default"]) {
        // Present helpful message
        return console.warn('Message source was not initialized!');
    }
    // Wait half second before sending the next message (avoid msg without answer)
    if (Math.abs(lastMsgSentAt.getTime() - Date.now()) / 1000 >= 0.5) {
        lastMsgSentAt = new Date();
        viewSource === null || viewSource === void 0 ? void 0 : viewSource.postMessage(message, '*');
    }
    else {
        lastMsgSentAt = new Date();
        setTimeout(function () {
            viewSource === null || viewSource === void 0 ? void 0 : viewSource.postMessage(message, '*');
        }, 500);
    }
};
exports.postMessage = postMessage;
/**
 * On get answer from the View
 * @param event
 */
var onGetMessage = function (event) {
    if (!viewSource && status === 'waiting-for-viewer-signal') {
        // Set the Messager source
        viewSource = event.source;
        // Save the welcome payload (connect)
        if (event.data.type === 'connect') {
            status = 'connected';
            // Successful connection message
            console.log('%c --- Near Social Bridge initialized ---', 'background: #282C34; color:#fff');
            // Set initial last message sent time
            lastMsgSentAt = new Date();
            // Dispath notification: connection established
            connectionPayload = event.data.payload;
            exports.onConnectObservable.notify(connectionPayload);
        }
    }
    // Notify all observers
    exports.bridgeServiceObservable.notify(event);
};
/**
 * Get the payload provided by the connection
 * @returns
 */
var getConnectionPayload = function () { return connectionPayload; };
exports.getConnectionPayload = getConnectionPayload;
/**
 * Get the current connection status
 */
var getConnectionStatus = function () { return status; };
exports.getConnectionStatus = getConnectionStatus;
/**
 * Init the service
 * @param viewMessageSource
 */
var initBridgeService = function () {
    // Process mock
    if (isDevelopment_1["default"] && isLocalDev_1["default"] && mock_1.globalMock[constants_1.LOCAL_MOCK_KEYS.INITIAL_PAYLOAD]) {
        connectionPayload.initialPayload = __assign({}, mock_1.globalMock[constants_1.LOCAL_MOCK_KEYS.INITIAL_PAYLOAD]());
    }
    // Normal Flow
    if (status === 'pending') {
        status = 'waiting-for-viewer-signal';
        window.addEventListener('message', onGetMessage, false);
        //DEV - clear observables when the app reload
        var handler_1 = function () {
            exports.bridgeServiceObservable.clear();
            exports.onConnectObservable.clear();
            window.removeEventListener('unload', handler_1);
        };
        window.addEventListener('unload', handler_1);
    }
};
exports.initBridgeService = initBridgeService;
