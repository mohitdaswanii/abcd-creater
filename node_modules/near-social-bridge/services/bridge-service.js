var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { LOCAL_MOCK_KEYS } from '../constants';
import { globalMock } from '../request/mock';
import isDevelopment from '../utils/isDevelopment';
import isLocalDev from '../utils/isLocalDev';
import Observable from '../utils/observable';
var viewSource;
var status = 'pending';
var connectionPayload = {};
/**
 * When any message comes
 */
export var bridgeServiceObservable = new Observable();
/**
 * When the connection is established
 */
export var onConnectObservable = new Observable();
// Message concurrency controll
var lastMsgSentAt = new Date();
/**
 * Post message
 * @param message
 * @returns
 */
export var postMessage = function (message) {
    if (!viewSource && !isLocalDev) {
        // Present helpful message
        return console.warn('Message source was not initialized!');
    }
    // Wait half second before sending the next message (avoid msg without answer)
    if (Math.abs(lastMsgSentAt.getTime() - Date.now()) / 1000 >= 0.5) {
        lastMsgSentAt = new Date();
        viewSource === null || viewSource === void 0 ? void 0 : viewSource.postMessage(message, '*');
    }
    else {
        lastMsgSentAt = new Date();
        setTimeout(function () {
            viewSource === null || viewSource === void 0 ? void 0 : viewSource.postMessage(message, '*');
        }, 500);
    }
};
/**
 * On get answer from the View
 * @param event
 */
var onGetMessage = function (event) {
    if (!viewSource && status === 'waiting-for-viewer-signal') {
        // Set the Messager source
        viewSource = event.source;
        // Save the welcome payload (connect)
        if (event.data.type === 'connect') {
            status = 'connected';
            // Successful connection message
            console.log('%c --- Near Social Bridge initialized ---', 'background: #282C34; color:#fff');
            // Set initial last message sent time
            lastMsgSentAt = new Date();
            // Dispath notification: connection established
            connectionPayload = event.data.payload;
            onConnectObservable.notify(connectionPayload);
        }
    }
    // Notify all observers
    bridgeServiceObservable.notify(event);
};
/**
 * Get the payload provided by the connection
 * @returns
 */
export var getConnectionPayload = function () { return connectionPayload; };
/**
 * Get the current connection status
 */
export var getConnectionStatus = function () { return status; };
/**
 * Init the service
 * @param viewMessageSource
 */
export var initBridgeService = function () {
    // Process mock
    if (isDevelopment && isLocalDev && globalMock[LOCAL_MOCK_KEYS.INITIAL_PAYLOAD]) {
        connectionPayload.initialPayload = __assign({}, globalMock[LOCAL_MOCK_KEYS.INITIAL_PAYLOAD]());
    }
    // Normal Flow
    if (status === 'pending') {
        status = 'waiting-for-viewer-signal';
        window.addEventListener('message', onGetMessage, false);
        //DEV - clear observables when the app reload
        var handler_1 = function () {
            bridgeServiceObservable.clear();
            onConnectObservable.clear();
            window.removeEventListener('unload', handler_1);
        };
        window.addEventListener('unload', handler_1);
    }
};
